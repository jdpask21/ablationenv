				goto ret1;
0.8404337167739868
		goto ret1;
0.11521406471729279
	return info;
-0.581260621547699
		N += xi[i] = sum;
-0.6901658773422241
			sum += (double)k;
-0.7681407928466797
				   : info < -2.5 ? "table too small\n"
-0.7995672225952148
			(void)fputs( info < -3.5 ? "out of memory\n"
-0.8417102694511414
	(void)printf( "\ntotal 2info = %5.2f\tdf = %2d\tq = %7.4f\n",
-0.8477751016616821
    ret2:
-0.8596227765083313
	free( (pointer)xi );
-0.8837167620658875
	return EXIT_SUCCESS;
-0.884696364402771
	if ( N <= 0.0 )
-0.8909330368041992
	if ( totdf <= 0 )
-0.8930158615112305
    ret3:
-0.9206259846687317
		for ( j = 0; j < c; ++j )
-0.935242772102356
			for ( j = 0; j < c; ++j )
-0.9368831515312195
	free( (pointer)xj );
-1.002600073814392
LGamma( x )
-1.0431809425354004
	for ( j = 0; j < c; ++j )
-1.0797169208526611
    ret1:
-1.09379243850708
		for ( i = 0; i < r; ++i )
-1.1032768487930298
		double	pix = PI * x;
-1.106943130493164
	info *= 2.0;			/* for comparability with chi-square */
-1.1200166940689087
	if ( --x < 0.0 )	/* use reflection formula for accuracy */
-1.1206519603729248
	tmp = x + 5.5;
-1.1275593042373657
			totdf += infodf;
-1.1441253423690796
			totinfo += info;
-1.1446845531463623
			(void)printf( "2info = %5.2f\tdf = %2d\tq = %7.4f\n",
-1.1530050039291382
		if ( info >= 0.0 )
-1.168108582496643
	for ( i = 0; i < r; ++i )
-1.1898304224014282
	tmp -= (x + 0.5) * log( tmp );
-1.1934400796890259
		info = InfoTbl( r, c, f, &infodf );
-1.1969571113586426
			if ( k < 0L )
-1.2172682285308838
	ser = 1.0;
-1.2181580066680908
		double	sum = 0.0;	/* accumulator */
-1.2195411920547485
		info = -1.0;
-1.2237142324447632
		ser += cof[j] / ++x;
-1.2319157123565674
	for ( j = 0; j < 6; ++j )
-1.2333086729049683
				if ( scanf( " %ld", &x(i,j) ) == 0 )
-1.2430670261383057
		info = -3.0;
-1.254017949104309
			info -= pj * log( pj );			/* part 4 */
-1.255120038986206
	info = N * log( N );					/* part 1 */
-1.260860800743103
	N = 0.0;
-1.262485146522522
	return -tmp + log( 2.50662827465 * ser );
-1.2658605575561523
			long	k = x(i,j);
-1.266245722770691
			sum += (double)x(i,j);
-1.2662711143493652
		if ( r * c > MAXTBL )
-1.2668166160583496
		if ( pi > 0.0 )
-1.2700388431549072
		xj[j] = sum;
-1.2711061239242554
		a1 = x * a0 + anf * a1;
-1.2789851427078247
			return sum * exp( -x + a * log( x ) - LGamma( a ) );
-1.2801835536956787
			(void)fputs( line, stdout );
-1.2803161144256592
gcf( a, x )
-1.2815778255462646
			info -= pi * log( pi );			/* part 2 */
-1.2845454216003418
	if ( (xi = (double *)malloc( r * sizeof(double) )) == NULL )
-1.2846221923828125
		return EXIT_FAILURE;
-1.2866054773330688
		b1 = x * b0 + anf * b1;
-1.2889009714126587
		double	pi = xi[i];	/* row sum */
-1.2901411056518555
		if ( Abs( del ) < Abs( sum ) * EPS )
-1.2902650833129883
main( argc, argv )
-1.290942907333374
			continue;
-1.2909729480743408
QGamma( a, x )
-1.2915065288543701
			gold = g - gold;
-1.291598916053772
		double	an = (double)n;
-1.2916265726089478
		a0 = (a1 + a0 * ana) * fac;
-1.2919833660125732
		sum += del *= x / ++ap;
-1.2923088073730469
		anf = an * fac;
-1.2927939891815186
		(void)fputs( "\n*** no information accumulated ***\n", stdout );
-1.293173909187317
			b0 = 0.0, a0 = 1.0, a1 = x;
-1.2936780452728271
	if ( x <= 0.0 )
-1.2949280738830566
		return log( pix / sin( pix ) ) - LGamma( 1.0 - x );
-1.2961676120758057
		goto ret3;
-1.2971335649490356
	if ( (xj = (double *)malloc( c * sizeof(double) )) == NULL )
-1.29733145236969
				return exp( -x + a * log( x ) - LGamma( a ) ) * g;
-1.2974897623062134
			if ( pij > 0.0 )
-1.2982839345932007
		b0 = (b1 + b0 * ana) * fac;
-1.2983030080795288
			gold = g;
-1.2983157634735107
gser( a, x )
-1.2983567714691162
	return x < a + 1.0 ? 1.0 - gser( a, x ) : gcf( a, x );
-1.2985727787017822
			if ( Abs( gold ) < EPS * Abs( g ) )
-1.2985923290252686
		if ( *p == '\0' )
-1.298663854598999
		if ( a1 != 0.0 )
-1.2986804246902466
	double		gold = 0.0, fac = 1.0, b1 = 1.0,
-1.2988208532333374
	for ( n = 1; n <= ITMAX; ++n )
-1.2992833852767944
	return QGamma( (double)df / 2.0, chisq / 2.0 );
-1.300162672996521
		if ( *p == COMMENT )
-1.3016971349716187
QChiSq( chisq, df )
-1.3017627000808716
			double	g = b1 * (fac = 1.0 / a1);
-1.3021126985549927
		double	ana = an - a;
-1.303110122680664
			double	pij = (double)x(i,j);
-1.3040626049041748
        totdf = 0;
-1.304643988609314
	while ( fgets( line, MAXLINE, stdin ) != NULL )	/* start new table */
-1.3048818111419678
		for ( p = line; *p != '\0' && isspace( (int)*p ); ++p )
-1.3054522275924683
			continue;	/* skip blank line */
-1.3063828945159912
	*pdf = rdf * cdf;		/* total degrees of freedom */
-1.306549072265625
	double		totinfo = 0.0;	/* accumulated information */
-1.3125131130218506
	int		cdf = c - 1;	/* column degrees of freedom */
-1.3142110109329224
				info += pij * log( pij );	/* part 3 */
-1.3163341283798218
		if ( sscanf( p, "%d %d\n", &r, &c ) != 2 )
-1.3199118375778198
	del = sum = 1.0 / (ap = a);
-1.3237055540084839
	int		rdf = r - 1;	/* row degrees of freedom */
-1.3244012594223022
	if ( rdf <= 0 || cdf <= 0 )
-1.3278450965881348
InfoTbl( r, c, f, pdf )
-1.3306801319122314
				info = -2.0;
-1.337609052658081
		double	pj = xj[j];	/* column sum */
-1.340628981590271
		if ( pj > 0.0 )
-1.359578013420105
